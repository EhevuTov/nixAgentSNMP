/*
 * Note: this file originally auto-generated by mib2c using
 *       version $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "linkTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement linkTable get routines.
 * TODO:240:M: Implement linkTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table linkTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkTable is subid 1 of myCorpProductMIB.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1, length: 11
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement linkTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param linkIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
linkTable_indexes_set_tbl_idx(linkTable_mib_index * tbl_idx,
                              u_long linkIndex_val)
{
    DEBUGMSGTL(("verbose:linkTable:linkTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * linkIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->linkIndex = linkIndex_val;


    return MFD_SUCCESS;
}                               /* linkTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
linkTable_indexes_set(linkTable_rowreq_ctx * rowreq_ctx,
                      u_long linkIndex_val)
{
    DEBUGMSGTL(("verbose:linkTable:linkTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        linkTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, linkIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != linkTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* linkTable_indexes_set */


/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.linkID
 * linkID is subid 2 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.2
 * Description:
Link number in regards to the Admin3000
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the linkID data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param linkID_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
linkID_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * linkID_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != linkID_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:linkID_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the linkID data.
     * copy (* linkID_val_ptr ) from rowreq_ctx->data
     */
    (*linkID_val_ptr) = rowreq_ctx->data.linkID;

    return MFD_SUCCESS;
}                               /* linkID_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.slc
 * slc is subid 3 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.3
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the slc data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param slc_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
slc_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * slc_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != slc_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:slc_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the slc data.
     * copy (* slc_val_ptr ) from rowreq_ctx->data
     */
    (*slc_val_ptr) = rowreq_ctx->data.slc;

    return MFD_SUCCESS;
}                               /* slc_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.corSet
 * corSet is subid 4 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.4
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the corSet data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param corSet_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
corSet_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * corSet_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != corSet_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:corSet_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the corSet data.
     * copy (* corSet_val_ptr ) from rowreq_ctx->data
     */
    (*corSet_val_ptr) = rowreq_ctx->data.corSet;

    return MFD_SUCCESS;
}                               /* corSet_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txPort
 * txPort is subid 5 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.5
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txPort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txPort_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txPort_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txPort_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txPort_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txPort_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txPort data.
     * copy (* txPort_val_ptr ) from rowreq_ctx->data
     */
    (*txPort_val_ptr) = rowreq_ctx->data.txPort;

    return MFD_SUCCESS;
}                               /* txPort_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txChan
 * txChan is subid 6 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.6
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txChan data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txChan_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txChan_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txChan_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txChan_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txChan_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txChan data.
     * copy (* txChan_val_ptr ) from rowreq_ctx->data
     */
    (*txChan_val_ptr) = rowreq_ctx->data.txChan;

    return MFD_SUCCESS;
}                               /* txChan_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txBran
 * txBran is subid 7 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.7
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txBran data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txBran_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txBran_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txBran_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txBran_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txBran_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txBran data.
     * copy (* txBran_val_ptr ) from rowreq_ctx->data
     */
    (*txBran_val_ptr) = rowreq_ctx->data.txBran;

    return MFD_SUCCESS;
}                               /* txBran_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txBrMgr
 * txBrMgr is subid 8 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.8
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txBrMgr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txBrMgr_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txBrMgr_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txBrMgr_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txBrMgr_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txBrMgr_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txBrMgr data.
     * copy (* txBrMgr_val_ptr ) from rowreq_ctx->data
     */
    (*txBrMgr_val_ptr) = rowreq_ctx->data.txBrMgr;

    return MFD_SUCCESS;
}                               /* txBrMgr_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.corBrMgr
 * corBrMgr is subid 9 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.9
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the corBrMgr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param corBrMgr_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
corBrMgr_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * corBrMgr_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != corBrMgr_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:corBrMgr_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the corBrMgr data.
     * copy (* corBrMgr_val_ptr ) from rowreq_ctx->data
     */
    (*corBrMgr_val_ptr) = rowreq_ctx->data.corBrMgr;

    return MFD_SUCCESS;
}                               /* corBrMgr_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.corBrCon
 * corBrCon is subid 10 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.10
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the corBrCon data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param corBrCon_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
corBrCon_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * corBrCon_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != corBrCon_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:corBrCon_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the corBrCon data.
     * copy (* corBrCon_val_ptr ) from rowreq_ctx->data
     */
    (*corBrCon_val_ptr) = rowreq_ctx->data.corBrCon;

    return MFD_SUCCESS;
}                               /* corBrCon_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.protocol
 * protocol is subid 11 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.11
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the protocol data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param protocol_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param protocol_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by protocol.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*protocol_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update protocol_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
protocol_get(linkTable_rowreq_ctx * rowreq_ctx,
             char **protocol_val_ptr_ptr, size_t *protocol_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != protocol_val_ptr_ptr)
                   && (NULL != *protocol_val_ptr_ptr));
    netsnmp_assert(NULL != protocol_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:linkTable:protocol_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the protocol data.
     * copy (* protocol_val_ptr_ptr ) data and (* protocol_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for protocol data
     */
    if ((NULL == (*protocol_val_ptr_ptr)) ||
        ((*protocol_val_ptr_len_ptr) <
         (rowreq_ctx->data.protocol_len *
          sizeof(rowreq_ctx->data.protocol[0])))) {
        /*
         * allocate space for protocol data
         */
        (*protocol_val_ptr_ptr) =
            malloc(rowreq_ctx->data.protocol_len *
                   sizeof(rowreq_ctx->data.protocol[0]));
        if (NULL == (*protocol_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.protocol)\n");
            return MFD_ERROR;
        }
    }
    (*protocol_val_ptr_len_ptr) =
        rowreq_ctx->data.protocol_len *
        sizeof(rowreq_ctx->data.protocol[0]);
    memcpy((*protocol_val_ptr_ptr), rowreq_ctx->data.protocol,
           rowreq_ctx->data.protocol_len *
           sizeof(rowreq_ctx->data.protocol[0]));

    return MFD_SUCCESS;
}                               /* protocol_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.time
 * time is subid 12 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.12
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the time data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param time_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
time_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * time_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != time_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:time_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the time data.
     * copy (* time_val_ptr ) from rowreq_ctx->data
     */
    (*time_val_ptr) = rowreq_ctx->data.time;

    return MFD_SUCCESS;
}                               /* time_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txISUP
 * txISUP is subid 13 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.13
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txISUP data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txISUP_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txISUP_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txISUP_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txISUP_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txISUP_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txISUP data.
     * copy (* txISUP_val_ptr ) from rowreq_ctx->data
     */
    (*txISUP_val_ptr) = rowreq_ctx->data.txISUP;

    return MFD_SUCCESS;
}                               /* txISUP_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxISUP
 * rxISUP is subid 14 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.14
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxISUP data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxISUP_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxISUP_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * rxISUP_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxISUP_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxISUP_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxISUP data.
     * copy (* rxISUP_val_ptr ) from rowreq_ctx->data
     */
    (*rxISUP_val_ptr) = rowreq_ctx->data.rxISUP;

    return MFD_SUCCESS;
}                               /* rxISUP_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txSCCP
 * txSCCP is subid 15 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.15
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txSCCP data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txSCCP_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txSCCP_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txSCCP_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txSCCP_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txSCCP_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txSCCP data.
     * copy (* txSCCP_val_ptr ) from rowreq_ctx->data
     */
    (*txSCCP_val_ptr) = rowreq_ctx->data.txSCCP;

    return MFD_SUCCESS;
}                               /* txSCCP_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxSCCP
 * rxSCCP is subid 16 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.16
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxSCCP data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxSCCP_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxSCCP_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * rxSCCP_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxSCCP_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxSCCP_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxSCCP data.
     * copy (* rxSCCP_val_ptr ) from rowreq_ctx->data
     */
    (*rxSCCP_val_ptr) = rowreq_ctx->data.rxSCCP;

    return MFD_SUCCESS;
}                               /* rxSCCP_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txSNMM
 * txSNMM is subid 17 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.17
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txSNMM data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txSNMM_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txSNMM_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txSNMM_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txSNMM_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txSNMM_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txSNMM data.
     * copy (* txSNMM_val_ptr ) from rowreq_ctx->data
     */
    (*txSNMM_val_ptr) = rowreq_ctx->data.txSNMM;

    return MFD_SUCCESS;
}                               /* txSNMM_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxSNMM
 * rxSNMM is subid 18 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.18
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxSNMM data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxSNMM_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxSNMM_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * rxSNMM_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxSNMM_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxSNMM_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxSNMM data.
     * copy (* rxSNMM_val_ptr ) from rowreq_ctx->data
     */
    (*rxSNMM_val_ptr) = rowreq_ctx->data.rxSNMM;

    return MFD_SUCCESS;
}                               /* rxSNMM_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txFISU
 * txFISU is subid 19 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.19
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txFISU data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txFISU_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txFISU_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txFISU_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txFISU_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txFISU_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txFISU data.
     * copy (* txFISU_val_ptr ) from rowreq_ctx->data
     */
    (*txFISU_val_ptr) = rowreq_ctx->data.txFISU;

    return MFD_SUCCESS;
}                               /* txFISU_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxFISU
 * rxFISU is subid 20 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.20
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxFISU data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxFISU_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxFISU_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * rxFISU_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxFISU_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxFISU_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxFISU data.
     * copy (* rxFISU_val_ptr ) from rowreq_ctx->data
     */
    (*rxFISU_val_ptr) = rowreq_ctx->data.rxFISU;

    return MFD_SUCCESS;
}                               /* rxFISU_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txOther
 * txOther is subid 21 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.21
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txOther data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txOther_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txOther_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txOther_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txOther_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txOther_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txOther data.
     * copy (* txOther_val_ptr ) from rowreq_ctx->data
     */
    (*txOther_val_ptr) = rowreq_ctx->data.txOther;

    return MFD_SUCCESS;
}                               /* txOther_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxOther
 * rxOther is subid 22 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.22
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxOther data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxOther_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxOther_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * rxOther_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxOther_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxOther_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxOther data.
     * copy (* rxOther_val_ptr ) from rowreq_ctx->data
     */
    (*rxOther_val_ptr) = rowreq_ctx->data.rxOther;

    return MFD_SUCCESS;
}                               /* rxOther_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txErr
 * txErr is subid 23 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.23
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txErr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txErr_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txErr_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * txErr_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txErr_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txErr_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txErr data.
     * copy (* txErr_val_ptr ) from rowreq_ctx->data
     */
    (*txErr_val_ptr) = rowreq_ctx->data.txErr;

    return MFD_SUCCESS;
}                               /* txErr_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxErr
 * rxErr is subid 24 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.24
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxErr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxErr_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxErr_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * rxErr_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxErr_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxErr_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxErr data.
     * copy (* rxErr_val_ptr ) from rowreq_ctx->data
     */
    (*rxErr_val_ptr) = rowreq_ctx->data.rxErr;

    return MFD_SUCCESS;
}                               /* rxErr_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.txErrRate
 * txErrRate is subid 25 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.25
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the txErrRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param txErrRate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
txErrRate_get(linkTable_rowreq_ctx * rowreq_ctx,
              u_long * txErrRate_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != txErrRate_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:txErrRate_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the txErrRate data.
     * copy (* txErrRate_val_ptr ) from rowreq_ctx->data
     */
    (*txErrRate_val_ptr) = rowreq_ctx->data.txErrRate;

    return MFD_SUCCESS;
}                               /* txErrRate_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.rxErrRate
 * rxErrRate is subid 26 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.26
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the rxErrRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param rxErrRate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
rxErrRate_get(linkTable_rowreq_ctx * rowreq_ctx,
              u_long * rxErrRate_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rxErrRate_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:rxErrRate_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the rxErrRate data.
     * copy (* rxErrRate_val_ptr ) from rowreq_ctx->data
     */
    (*rxErrRate_val_ptr) = rowreq_ctx->data.rxErrRate;

    return MFD_SUCCESS;
}                               /* rxErrRate_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.unitID
 * unitID is subid 27 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.27
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the unitID data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param unitID_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
unitID_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * unitID_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != unitID_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:unitID_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the unitID data.
     * copy (* unitID_val_ptr ) from rowreq_ctx->data
     */
    (*unitID_val_ptr) = rowreq_ctx->data.unitID;

    return MFD_SUCCESS;
}                               /* unitID_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.linkSet
 * linkSet is subid 28 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.28
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the linkSet data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param linkSet_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
linkSet_get(linkTable_rowreq_ctx * rowreq_ctx, u_long * linkSet_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != linkSet_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:linkSet_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the linkSet data.
     * copy (* linkSet_val_ptr ) from rowreq_ctx->data
     */
    (*linkSet_val_ptr) = rowreq_ctx->data.linkSet;

    return MFD_SUCCESS;
}                               /* linkSet_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.originCLLI
 * originCLLI is subid 29 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.29
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the originCLLI data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param originCLLI_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param originCLLI_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by originCLLI.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*originCLLI_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update originCLLI_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
originCLLI_get(linkTable_rowreq_ctx * rowreq_ctx,
               char **originCLLI_val_ptr_ptr,
               size_t *originCLLI_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != originCLLI_val_ptr_ptr)
                   && (NULL != *originCLLI_val_ptr_ptr));
    netsnmp_assert(NULL != originCLLI_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:linkTable:originCLLI_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the originCLLI data.
     * copy (* originCLLI_val_ptr_ptr ) data and (* originCLLI_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for originCLLI data
     */
    if ((NULL == (*originCLLI_val_ptr_ptr)) ||
        ((*originCLLI_val_ptr_len_ptr) <
         (rowreq_ctx->data.originCLLI_len *
          sizeof(rowreq_ctx->data.originCLLI[0])))) {
        /*
         * allocate space for originCLLI data
         */
        (*originCLLI_val_ptr_ptr) =
            malloc(rowreq_ctx->data.originCLLI_len *
                   sizeof(rowreq_ctx->data.originCLLI[0]));
        if (NULL == (*originCLLI_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.originCLLI)\n");
            return MFD_ERROR;
        }
    }
    (*originCLLI_val_ptr_len_ptr) =
        rowreq_ctx->data.originCLLI_len *
        sizeof(rowreq_ctx->data.originCLLI[0]);
    memcpy((*originCLLI_val_ptr_ptr), rowreq_ctx->data.originCLLI,
           rowreq_ctx->data.originCLLI_len *
           sizeof(rowreq_ctx->data.originCLLI[0]));

    return MFD_SUCCESS;
}                               /* originCLLI_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.destinCLLI
 * destinCLLI is subid 30 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.30
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the destinCLLI data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param destinCLLI_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param destinCLLI_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by destinCLLI.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*destinCLLI_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update destinCLLI_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
destinCLLI_get(linkTable_rowreq_ctx * rowreq_ctx,
               char **destinCLLI_val_ptr_ptr,
               size_t *destinCLLI_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != destinCLLI_val_ptr_ptr)
                   && (NULL != *destinCLLI_val_ptr_ptr));
    netsnmp_assert(NULL != destinCLLI_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:linkTable:destinCLLI_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the destinCLLI data.
     * copy (* destinCLLI_val_ptr_ptr ) data and (* destinCLLI_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for destinCLLI data
     */
    if ((NULL == (*destinCLLI_val_ptr_ptr)) ||
        ((*destinCLLI_val_ptr_len_ptr) <
         (rowreq_ctx->data.destinCLLI_len *
          sizeof(rowreq_ctx->data.destinCLLI[0])))) {
        /*
         * allocate space for destinCLLI data
         */
        (*destinCLLI_val_ptr_ptr) =
            malloc(rowreq_ctx->data.destinCLLI_len *
                   sizeof(rowreq_ctx->data.destinCLLI[0]));
        if (NULL == (*destinCLLI_val_ptr_ptr)) {
            snmp_log(LOG_ERR,
                     "could not allocate memory (rowreq_ctx->data.destinCLLI)\n");
            return MFD_ERROR;
        }
    }
    (*destinCLLI_val_ptr_len_ptr) =
        rowreq_ctx->data.destinCLLI_len *
        sizeof(rowreq_ctx->data.destinCLLI[0]);
    memcpy((*destinCLLI_val_ptr_ptr), rowreq_ctx->data.destinCLLI,
           rowreq_ctx->data.destinCLLI_len *
           sizeof(rowreq_ctx->data.destinCLLI[0]));

    return MFD_SUCCESS;
}                               /* destinCLLI_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.originPtCd
 * originPtCd is subid 31 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.31
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the originPtCd data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param originPtCd_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
originPtCd_get(linkTable_rowreq_ctx * rowreq_ctx,
               u_long * originPtCd_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != originPtCd_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:originPtCd_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the originPtCd data.
     * copy (* originPtCd_val_ptr ) from rowreq_ctx->data
     */
    (*originPtCd_val_ptr) = rowreq_ctx->data.originPtCd;

    return MFD_SUCCESS;
}                               /* originPtCd_get */

/*---------------------------------------------------------------------
 * MYCORP-PRODUCT-MYPRODUCT-MIB::linkEntry.destinPtCd
 * destinPtCd is subid 32 of linkEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.36872.2.1.1.1.1.32
 * Description:
signalling code number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the destinPtCd data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param destinPtCd_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
destinPtCd_get(linkTable_rowreq_ctx * rowreq_ctx,
               u_long * destinPtCd_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != destinPtCd_val_ptr);


    DEBUGMSGTL(("verbose:linkTable:destinPtCd_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the destinPtCd data.
     * copy (* destinPtCd_val_ptr ) from rowreq_ctx->data
     */
    (*destinPtCd_val_ptr) = rowreq_ctx->data.destinPtCd;

    return MFD_SUCCESS;
}                               /* destinPtCd_get */



/** @} */
